package com.leetcode;

import java.util.Arrays;

/**
 * father 整型数组，<br />
 * 并查集主要成员<br />
 * 不解释。<br />
 * <hr>
 * virus 布尔数组，<br />
 * 主要标识哪个点是病毒<br />
 * <hr>
 * infect 整型数组，<br />
 * 以集合的根标识整个集合是否与病毒点有接触<br />
 * -1无接触<br />
 * >=0有接触，且为infect[a],<br />
 * (a是集合的代表点，到时任意点通过find可达)<br />
 * -2代表接触了两个点，死定了。<br />
 * <hr>
 * size 整型数组，<br />
 * 代表一个集合的点数量。<br />
 * <hr>
 * cnts 整型数组，<br />
 * 解除一个病毒点，可使多少点免于感染<br />
 * <hr>
 * tmd四个属性数组。<br />
 *
 * @author Yabo
 * @date 2024/09/03
 */
class lc928_MinimizeMalwareSpreadII {

    // 如果测试数据变大，就改变这个值
    public static int MAXN = 301;

    // [3,6,103]
    // virus[3] = true;
    // virus[103] = true;
    // 方便查询
    public static boolean[] virus = new boolean[MAXN];

    // 每个源头点删掉的话，能拯救多少点的数据
    public static int[] cnts = new int[MAXN];

    // 集合的标签 : 集合的感染点是什么点
    // a : 代表点，整个集合源头是 infect[a]
    // infect[a] == -1，目前这个集合没有发现源头
    // infect[a] >= 0，目前这个集合源头是 infect[a]
    // infect[a] == -2，目前这个集合源头不止一个，已经无法拯救了!
    public static int[] infect = new int[MAXN];

    // 集合的标签 : 集合的大小是多少
    public static int[] size = new int[MAXN];

    // 并查集固有信息
    public static int[] father = new int[MAXN];

    public static void build(int n, int[] initial) {
        // 1. 第一步初始化
        for (int i = 0; i < n; i++) {
            // 默认每个不是病毒
            virus[i] = false;
            // 免感染数初始为0
            cnts[i] = 0;
            // 示意还未接触到病毒
            infect[i] = -1;
            // 默认集合大小为1
            size[i] = 1;
            // 默认集合根为自己
            father[i] = i;
        }
        // 2. 第二步初始化
        for (int i : initial) {
            virus[i] = true;
        }
    }

    public static int find(int i) {
        if (i != father[i]) {
            father[i] = find(father[i]);
        }
        return father[i];
    }

    public static void union(int x, int y) {
        int fx = find(x);
        int fy = find(y);
        if (fx != fy) {
            father[fx] = fy;
            // 集合大小也要合并
            size[fy] += size[fx];
        }
    }


    public int minMalwareSpread(int[][] graph, int[] initial) {
        // 1. 获取点的数量
        int n = graph.length;
        // 2. 初始化并查集结构
        build(n, initial);
        // 3. 双层for循环，结束后所有非病毒点已合并
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (graph[i][j] == 1 && !virus[i] && !virus[j]) {
                    union(i, j);
                }
            }
        }
        // 4. 双层for循环，结束后可设置所有集合的接触点状态
        // 	1. 遍历病毒点
        // 	2. 遍历除病毒点之外的所有与其有联系的点，(你tm写了不看是吧！！)
        // 	当找到后，根据其已有状态，
        // 	对其所属集合根的infect数组进行设置。
        // 	状态机很多，但需要处理的状态只有两种。
        // 	一种是-1，也就是还未接触病毒点：infect数组赋值为病毒点
        // 	一种是不是-2且上一个感染点不是当前点：判入绝症，infect数组赋值为-2
        for (int sick : initial) { // 你是不是沙，这tm是把所有病毒点拿出来遍历，不是遍历它有多少！
            for (int neighbor = 0; neighbor < n; neighbor++) {
                if (sick != neighbor && !virus[neighbor] && graph[sick][neighbor] == 1) {
                    int fn = find(neighbor);
                    if (infect[fn] == -1) {
                        infect[fn] = sick;
                    } else if (infect[fn] != -2 && infect[fn] != sick) {
                        infect[fn] = -2;
                    }
                }
            }
        }
        // 5. 统计所有病毒点被删后可赦免多少点。
        // 	具体规则是只看每个点所属集合的根以及infect[i]是否>=0
        // 	符合规则的集合size计入cnts[infect[i]];
        for (int i = 0; i < n; i++) {
            if (i == find(i) && infect[i] >= 0) { // 你这么写是：是根才处理！这和你上面写的不一样！
                cnts[infect[i]] += size[i];
            }
        }
        // 6. 排序所有病毒点
        Arrays.sort(initial);
        // 7. 用赦免数组最大值来寻找索引最小的病毒点，需要一个for循环。
        int ans = initial[0];
        int max = cnts[ans];
        for (int i : initial) {
            if (max < cnts[i]) {
                ans = i;
                max = cnts[i];
            }
        }
        // 8. 返回答案。
        return ans;

    }
}
